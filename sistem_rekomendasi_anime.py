# -*- coding: utf-8 -*-
"""Sistem Rekomendasi Anime.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZgRUe8FCMHpO6Rgz0Rt1EvJSsVJ4NES5

# Sistem Rekomendasi Anime

## Project Overview

Dalam beberapa tahun terakhir, popularitas anime telah meningkat secara signifikan di seluruh dunia. Dikutip dari jurnal "Kepopuleran dan Penerimaan Anime Jepang di Indonesia", penggemar anime kini lebih sering menikmati anime melalui layanan streaming atau aplikasi khusus anime seperti Netflix dan AbemaTV. Selain itu, platform seperti MyAnimeList menyediakan tempat bagi penggemar anime untuk menonton, mengulas, dan memberikan peringkat pada anime favorit mereka.

Seiring dengan pertumbuhan jumlah pengguna dan variasi anime yang terus berkembang, MyAnimeList memiliki kebutuhan untuk memahami bagaimana preferensi pengguna terbentuk serta bagaimana berbagai faktor memengaruhi rating yang diberikan pada anime. Hal ini penting agar platform dapat meningkatkan kualitas rekomendasi anime yang lebih sesuai dengan preferensi setiap individu.

Dikutip dari jurnal "Rekomendasi Anime dengan Latent Semantic Indexing Berbasis Sinopsis Genre", semakin banyaknya jumlah anime yang beredar saat ini membuat penonton sering kali kesulitan menemukan anime yang sesuai dengan selera mereka. Oleh karena itu, dengan adanya dataset preferensi pengguna yang besar dari MyAnimeList, kita dapat mengeksplorasi pola preferensi ini untuk membangun sistem rekomendasi yang lebih baik dan relevan, sehingga membantu pengguna menemukan anime yang sesuai dengan minat mereka.

Referensi :
* https://www.researchgate.net/profile/Hapnes-Toba/publication/274712918_Rekomendasi_Anime_dengan_Latent_Semantic_Indexing_Berbasis_Sinopsis_Genre/links/5527488f0cf2e486ae40fd8b/Rekomendasi-Anime-dengan-Latent-Semantic-Indexing-Berbasis-Sinopsis-Genre.pdf

* https://ejournal.unitomo.ac.id/index.php/ayumi/article/view/2808

## Business Understanding

### Problem Statements

* Berdasarkan data mengenai pengguna, bagaimana membuat sistem rekomendasi anime yang dipersonalisasi dengan teknik content-based filtering?
* Dengan data rating dan genre anime yang ada, bagaimana situs MyAnimeList dapat merekomendasikan anime lain yang mungkin disukai dan belum pernah dilihat oleh penonton anime?

### Goals
Untuk  menjawab problem statement di atas, dibuatlah sistem rekomendasi dengan tujuan atau goals sebagai berikut:

* Menghasilkan sejumlah rekomendasi anime yang dipersonalisasi untuk pengguna dengan teknik content-based filtering.
* Menghasilkan sejumlah rekomendasi anime yang sesuai dengan preferensi penonton dan belum pernah dilihat oleh penonton tersebut sebelumnya dengan teknik collaborative filtering.

### Solution Approach

* Content-based Filtering: Menggunakan data genre untuk membuat rekomendasi berdasarkan anime yang telah disukai pengguna sebelumnya.
* Collaborative Filtering: Menggunakan pendekatan berbasis kesamaan pengguna untuk merekomendasikan anime yang ditonton oleh pengguna dengan preferensi serupa.

## Data Understanding
"""

# Import Library

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from google.colab import drive

drive.mount('/content/drive')

# Load Data

anime_df = pd.read_csv('/content/drive/MyDrive/Kaggle/Dataset Anime/anime.csv')
rating_df = pd.read_csv('/content/drive/MyDrive/Kaggle/Dataset Anime/rating.csv')

"""Dataset yang digunakan berasal dari MyAnimeList dan terdiri dari dua file utama, yaitu :

1) Anime.csv

2) Rating.csv

### Exploratory Data Analysis

#### Data Anime
"""

anime_df.head()

anime_df.shape

"""Pada Anime.csv, terdapat 12.294 baris data dengan 7 fitur"""

anime_df.info()

"""Deskripsi variabel yang ada pada Anime.csv :

* anime_id: ID unik dari setiap anime.
* name: Nama lengkap dari anime.
* genre: Daftar genre anime yang dipisahkan oleh koma.
* type: Jenis anime, seperti TV, Movie, atau OVA.
* episodes: Jumlah episode untuk setiap anime (jika film, jumlahnya adalah 1).
* rating: Rata-rata rating dari komunitas untuk anime tersebut, dari skala 1 sampai 10.
* members: Jumlah anggota komunitas yang tergabung dalam grup anime tersebut.
"""

anime_df.describe()

# Cek Missing Data

anime_df.isnull().sum()

"""Terdapat nilai kosong pada beberapa kolom, karena jumlahnya dikit maka hapus saja"""

# Hapus Data Kosong

anime_df.dropna(inplace=True)
anime_df.isnull().sum()

# Cek Data Duplikat

anime_df.duplicated().sum()

"""Tidak ada data yang terduplikat"""

# Plot histogram untuk distribusi rating

plt.figure(figsize=(8,6))
sns.histplot(data=anime_df, x='rating', bins=20, kde=True)
plt.title('Distribusi Rating Anime')
plt.xlabel('Rating')
plt.ylabel('Jumlah Anime')
plt.show()

"""Sebagaian besar anime yang ada mendapatkan rating antara 6 - 7 dari skala 1 - 10"""

# Plot pie chart untuk jenis anime

plt.figure(figsize=(8,8))
anime_df['type'].value_counts().plot.pie(autopct='%1.1f%%', colors=sns.color_palette('Set2'), startangle=90)
plt.title('Distribusi Jenis Anime')
plt.ylabel('')
plt.show()

"""Sekitar 57% dari anime yang ada, disajikan dalam bentuk serial TV dan tambahan OVA"""

# Highest Rating Anime

# Sort dataset berdasarkan rating tertinggi, kemudian ambil 5 teratas
top_10_anime = anime_df.nlargest(10, 'rating')

# Plot bar chart untuk top 10 highest rating anime
plt.figure(figsize=(10,6))
sns.barplot(x='rating', y='name', data=top_10_anime, palette='viridis')
plt.title("Top 10 Highest Rating Anime")
plt.xlabel("Rating", fontsize=14)
plt.ylabel("Nama Anime", fontsize=14)

plt.show()

"""Anime tertinggi di anime adalah "Taka no Tsume 8". Selain itu, anime berjudul Gintama memiliki 2 seasons dengan rating yang tinggi"""

# Pisahkan genre menjadi list
anime_df['genre_split'] = anime_df['genre'].str.split(', ')

# Menghitung jumlah kemunculan setiap genre
from collections import Counter
genre_counter = Counter([genre for genres in anime_df['genre_split'] for genre in genres])

top_5_genres = genre_counter.most_common(5)

top_genre_names = [genre for genre, count in top_5_genres]
top_genre_counts = [count for genre, count in top_5_genres]

# Plot bar chart untuk distribusi genre
plt.figure(figsize=(10,6))
sns.barplot(x=top_genre_names, y=top_genre_counts)
plt.xticks(rotation=90)
plt.title('Jumlah Anime Berdasarkan Genre')
plt.xlabel('Genre')
plt.ylabel('Jumlah Anime')
plt.show()

"""Anime ber genre Comedy berjumlah paling banyak, kemudian diikuti genre Action, Adventure, dan Fantasy"""

# Mengambil top 10 anime dengan members terbanyak
top_anime = anime_df.nlargest(10, 'members')

# Plot bar chart untuk anime terpopuler
plt.figure(figsize=(10,6))
sns.barplot(x='members', y='name', data=top_anime)
plt.title('Top 10 Anime Berdasarkan Jumlah Anggota Komunitas')
plt.xlabel('Jumlah Anggota Komunitas')
plt.ylabel('Anime')
plt.show()

"""Death Note menjadi anime yang memiliki member paling banyak dalam komunitas anime nya. Diikuti dengan anime Shingeki no Kyojin dan Sword Art Online

#### Data Rating
"""

rating_df.sample(5)

"""Value kolom rating yang berisi "-1", berarti user tersebut hanya menonton tidak memberi rating"""

rating_df.shape

"""Pada Rating.csv, terdapat 7.813.737 baris data dengan 3 fitur"""

rating_df.info()

"""Deskripsi variabel yang ada pada Rating.csv

* user_id: ID pengguna yang diacak dan tidak dapat diidentifikasi.
* anime_id: ID anime yang dinilai oleh pengguna.
* rating: Rating dari pengguna, dari skala 1 sampai 10 (nilai -1 jika pengguna menonton tapi tidak memberikan rating).
"""

rating_df.describe()

"""## Data Preparation"""

# Merge Data

# Menggabungkan dataset anime dan rating berdasarkan kolom 'anime_id'
df = pd.merge(anime_df, rating_df, on="anime_id", suffixes=[None, "_user"])

# Ubah nama kolom 'rating_user' menjadi 'user_rating' untuk clarity
df = df.rename(columns={"rating_user": "user_rating"})

df.head()

# Cek Data Kosong

df.isna().sum()

# Membuat salinan dataset

anime_data = df.copy()

# Mengonversi data series ‘placeID’ menjadi dalam bentuk list
anime_id = anime_data['anime_id'].tolist()

# Mengonversi data series ‘Name’ menjadi dalam bentuk list
anime_name = anime_data['name'].tolist()

# Mengonversi data series ‘Rcuisine’ menjadi dalam bentuk list
anime_genre = anime_data['genre'].tolist()

# Membuat dataset untuk Rekomendasi Berdasarkan Genre

anime_new = pd.DataFrame({
    'id': anime_id,
    'anime_name': anime_name,
    'genre': anime_genre
})
anime_new

# Cek Data Duplikat

anime_new.duplicated().sum()

# Hapus Data Duplikat

anime_new.drop_duplicates(inplace=True)
anime_new.duplicated().sum()

# Memecah Genre Anime

# Hapus delimiter
def get_string(row):
    result_string = row.genre
    result_string = result_string.replace(', ',' ')
    return  result_string
anime_new['genre'] = anime_new.apply(get_string,axis=1)

# Cek hasil preprocessing
anime_new.head()

"""## Modeling - Content-Based Filtering"""

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

"""#### TF-IDF Vectorizer"""

# Inisialisasi TF-IDF Vectorizer
tfidf = TfidfVectorizer(stop_words='english')

# Fit dan transformasi genre ke dalam TF-IDF Matrix
tfidf_matrix = tfidf.fit_transform(anime_new['genre'])

# Lihat ukuran TF-IDF Matrix (jumlah anime x jumlah genre unik)
tfidf_matrix.shape

"""Perhatikanlah, matriks yang kita miliki berukuran (11162, 46). Nilai 11162 merupakan ukuran data dan 46 merupakan matrik kategori genre anime."""

# Mengubah vektor tf-idf dalam bentuk matriks dengan fungsi todense()
tfidf_matrix.todense()

# Membuat dataframe untuk melihat tf-idf matrix
# Kolom diisi dengan genre
# Baris diisi dengan nama anime

anime_genres = pd.DataFrame(
    tfidf_matrix.todense(),  # Matrix hasil dari TF-IDF
    columns=tfidf.get_feature_names_out(),  # Genre sebagai kolom
    index=anime_new['anime_name']  # Nama anime sebagai baris
).sample(22, axis=1).sample(10, axis=0)  # Sampel 22 genre dan 10 anime

anime_genres

"""Output matriks tf-idf di atas menunjukkan Anime Aoi Kokuhaku memiliki genre Hentai. Hal ini terlihat dari nilai matriks 1.0 pada genre Hentai. Selanjutnya, anime Black Lagoon termasuk dalam genre Seinen dan Action, karena terdapat nilai matriks yang mendekati 1 pada kolom kedua genre tersebut. Demikian seterusnya.

#### Cosine Similiarity
"""

from sklearn.metrics.pairwise import cosine_similarity

# Menghitung cosine similarity pada matrix tf-idf
cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

"""Pada tahapan ini, kita menghitung cosine similarity dataframe tfidf_matrix yang kita peroleh pada tahapan sebelumnya. Dengan satu baris kode untuk memanggil fungsi cosine similarity dari library sklearn, kita telah berhasil menghitung kesamaan (similarity) antar anime. Kode di atas menghasilkan keluaran berupa matriks kesamaan dalam bentuk array."""

# Membuat dataframe dari variabel cosine_sim dengan baris dan kolom berupa nama resto
cosine_sim_df = pd.DataFrame(
    cosine_sim,
    columns=anime_new['anime_name'],
    index=anime_new['anime_name']
)
print('Shape:', cosine_sim_df.shape)

# Melihat similarity matrix pada setiap resto
cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

"""Perhatikanlah output matriks di atas. Semakin nilai angka mendekati 1.0 mengindikasikan bahwa anime pada kolom X (horizontal) memiliki kesamaan dengan anime pada baris Y (vertikal). Sebagai contoh, anime Pareo wa Emerald memiliki kemiripan (similiarity) dengan anime Hikenai Guitar wo Hikundaze berdasarkan genre nya.

#### Membuat Rekomendasi Anime

Di sini, kita membuat fungsi anime_recommendations dengan beberapa parameter sebagai berikut:

* nama_anime : Nama anime (index kemiripan dataframe).
* similarity_data : Dataframe mengenai similarity yang telah kita definisikan sebelumnya.
* items : Nama dan fitur yang digunakan untuk mendefinisikan kemiripan, dalam hal ini adalah ‘anime_name’ dan genre.
* k : Banyak rekomendasi yang ingin diberikan.
"""

def anime_recommendations(nama_anime, similarity_data=cosine_sim_df, items=anime_new[['anime_name', 'genre']], k=5):
    """
    Rekomendasi anime berdasarkan kemiripan dataframe

    Parameter:
    ---
    nama_anime : tipe data string (str)
                Nama anime (index kemiripan dataframe)
    similarity_data : tipe data pd.DataFrame (object)
                      Kesamaan dataframe, simetrik, dengan anime sebagai
                      indeks dan kolom
    items : tipe data pd.DataFrame (object)
            Mengandung kedua nama dan fitur lainnya yang digunakan untuk mendefinisikan kemiripan
    k : tipe data integer (int)
        Banyaknya jumlah rekomendasi yang diberikan
    ---


    Pada index ini, kita mengambil k dengan nilai similarity terbesar
    pada index matrix yang diberikan (i).
    """


    # Mengambil data dengan menggunakan argpartition untuk melakukan partisi secara tidak langsung sepanjang sumbu yang diberikan
    # Dataframe diubah menjadi numpy
    # Range(start, stop, step)
    index = similarity_data.loc[:,nama_anime].to_numpy().argpartition(
        range(-1, -k, -1))

    # Mengambil data dengan similarity terbesar dari index yang ada
    closest = similarity_data.columns[index[-1:-(k+2):-1]]

    # Drop nama_anime agar nama anime yang dicari tidak muncul dalam daftar rekomendasi
    closest = closest.drop(nama_anime, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

"""Dengan menggunakan argpartition, kita mengambil sejumlah nilai k tertinggi dari similarity data (dalam kasus ini: dataframe cosine_sim_df). Kemudian, kita mengambil data dari bobot (tingkat kesamaan) tertinggi ke terendah. Data ini dimasukkan ke dalam variabel closest. Berikutnya, kita perlu menghapus nama_anime yang yang dicari agar tidak muncul dalam daftar rekomendasi.

Contoh di bawah ini, kita akan mencari anime yang mirip dengan "Mob Psycho 100", sehingga kita perlu drop nama_anime "Mob Psycho 100" agar tidak muncul dalam daftar rekomendasi yang diberikan nanti.
"""

anime_new[anime_new.anime_name.eq('Mob Psycho 100')]

"""Perhatikanlah, "Mob Psycho 100" masuk dalam genre Action Comedy Slice of Life Supernatural. Tentu kita berharap rekomendasi yang diberikan adalah anime dengan kategori yang mirip. Nah, sekarang, dapatkan anime recommendation dengan memanggil fungsi yang telah kita definisikan sebelumnya:"""

anime_recommendations('Mob Psycho 100')

anime_recommendations('Naruto')

"""## Modeling - Collaborative Filtering"""

# import library

from zipfile import ZipFile
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from pathlib import Path
import matplotlib.pyplot as plt

"""#### Data Preparation"""

df = rating_df
df

"""Hapus data rating yang bernilai -1, karena hal tersebut menunjukkan bahwa user hanya menonton tanpa memberi rating"""

df = df[df['rating'] != -1]
df.head()

df.shape

"""Ternyata data banyak sekali, disini saya akan mengambil 2000 data saja. Hal ini dikarenakan keterbatasan komputasi"""

df = df[:2000]

df.shape

"""Pada tahap ini, Anda perlu melakukan persiapan data untuk menyandikan (encode) fitur ‘user_id’ dan ‘anime_id’ ke dalam indeks integer."""

# Mengubah user_id menjadi list tanpa nilai yang sama
user_ids = df['user_id'].unique().tolist()
print('list user_id: ', user_ids)

# Melakukan encoding user_id
user_to_user_encoded = {x: i for i, x in enumerate(user_ids)}
print('encoded user_id: ', user_to_user_encoded)

# Melakukan proses encoding angka ke ke user_id
user_encoded_to_user = {i: x for i, x in enumerate(user_ids)}
print('encoded angka ke user_id: ', user_encoded_to_user)

# Mengubah anime_id menjadi list tanpa nilai yang sama
anime_ids = df['anime_id'].unique().tolist()

# Melakukan proses encoding anime_id
anime_to_anime_encoded = {x: i for i, x in enumerate(anime_ids)}

# Melakukan proses encoding angka ke anime_id
anime_encoded_to_anime = {i: x for i, x in enumerate(anime_ids)}
print('encoded angka ke userID: ', anime_encoded_to_anime)

# Mapping user_id ke dataframe user
df['user'] = df['user_id'].map(user_to_user_encoded)

# Mapping anime_id ke dataframe anime
df['anime'] = df['anime_id'].map(anime_to_anime_encoded)

# Mendapatkan jumlah user
num_users = len(user_to_user_encoded)
print(num_users)

# Mendapatkan jumlah anime
num_anime = len(anime_encoded_to_anime)
print(num_anime)

# Mengubah rating menjadi nilai float
df['rating'] = df['rating'].values.astype(np.float32)

# Nilai minimum rating
min_rating = min(df['rating'])

# Nilai maksimal rating
max_rating = max(df['rating'])

print('Number of User: {}, Number of anime: {}, Min Rating: {}, Max Rating: {}'.format(
    num_users, num_anime, min_rating, max_rating
))

"""Tahap persiapan telah selesai. Berikut adalah hal-hal yang telah kita lakukan pada tahap ini:

* Memahami data rating yang kita miliki.
* Menyandikan (encode) fitur ‘user_id’ dan 'anime_id' ke dalam indeks integer.
* Memetakan ‘user_id’ dan 'anime_id' ke dataframe yang berkaitan.
* Mengecek beberapa hal dalam data seperti jumlah user, jumlah anime, kemudian mengubah nilai rating menjadi float.

Tahap persiapan ini penting dilakukan agar data siap digunakan untuk pemodelan. Namun sebelumnya, kita perlu membagi data untuk training dan validasi terlebih dahulu

#### Splitting Data
"""

# Mengacak dataset
df = df.sample(frac=1, random_state=42)
df

"""Selanjutnya, bagi data train dan validasi dengan komposisi 80:20. Namun sebelumnya, kita perlu memetakan (mapping) data user dan anime menjadi satu value terlebih dahulu. Lalu, buatlah rating dalam skala 0 sampai 1 agar mudah dalam melakukan proses training."""

# Membuat variabel x untuk mencocokkan data user dan anime menjadi satu value
x = df[['user','anime']].values

# Membuat variabel y untuk membuat rating dari hasil
y = df['rating'].apply(lambda x: (x - min_rating) / (max_rating - min_rating)).values

# Membagi menjadi 80% data train dan 20% data validasi
train_indices = int(0.8 * df.shape[0])
x_train, x_val, y_train, y_val = (
    x[:train_indices],
    x[train_indices:],
    y[:train_indices],
    y[train_indices:]
)

print(x, y)

"""Di sini, kita membuat class RecommenderNet dengan keras Model class. Kode class RecommenderNet ini terinspirasi dari tutorial dalam situs Keras dengan beberapa adaptasi sesuai kasus yang sedang kita selesaikan"""

class RecommenderNet(tf.keras.Model):

  # Insialisasi fungsi
  def __init__(self, num_users, num_anime, embedding_size, **kwargs):
    super(RecommenderNet, self).__init__(**kwargs)
    self.num_users = num_users
    self.num_anime = num_anime
    self.embedding_size = embedding_size
    self.user_embedding = layers.Embedding( # layer embedding user
        num_users,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.user_bias = layers.Embedding(num_users, 1) # layer embedding user bias
    self.anime_embedding = layers.Embedding( # layer embeddings anime
        num_anime,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.anime_bias = layers.Embedding(num_anime, 1) # layer embedding anime bias

  def call(self, inputs):
    user_vector = self.user_embedding(inputs[:,0]) # memanggil layer embedding 1
    user_bias = self.user_bias(inputs[:, 0]) # memanggil layer embedding 2
    anime_vector = self.anime_embedding(inputs[:, 1]) # memanggil layer embedding 3
    anime_bias = self.anime_bias(inputs[:, 1]) # memanggil layer embedding 4

    dot_user_anime = tf.tensordot(user_vector, anime_vector, 2)

    x = dot_user_anime + user_bias + anime_bias

    return tf.nn.sigmoid(x) # activation sigmoid

model = RecommenderNet(num_users, num_anime, 50) # inisialisasi model

# model compile
model.compile(
    loss = tf.keras.losses.BinaryCrossentropy(),
    optimizer = keras.optimizers.Adam(learning_rate=0.001),
    metrics=[tf.keras.metrics.RootMeanSquaredError()]
)

# Memulai training

history = model.fit(
    x = x_train,
    y = y_train,
    batch_size = 8,
    epochs = 100,
    validation_data = (x_val, y_val)
)

"""#### Evaluasi"""

plt.plot(history.history['root_mean_squared_error'])
plt.plot(history.history['val_root_mean_squared_error'])
plt.title('model_metrics')
plt.ylabel('root_mean_squared_error')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.show()

"""proses training model cukup smooth dan model konvergen pada epochs sekitar 100. Dari proses ini, kita memperoleh nilai error akhir sebesar sekitar 0.09 dan error pada data validasi sebesar 0.2. Nilai tersebut cukup bagus untuk sistem rekomendasi

Untuk mendapatkan rekomendasi anime, pertama kita ambil sampel user secara acak dan definisikan variabel anime_not_visited yang merupakan daftar anime yang belum pernah ditonton oleh pengguna.

Sebelumnya, pengguna telah memberi rating pada beberapa anime yang telah mereka tonton. Kita menggunakan rating ini untuk membuat rekomendasi anime yang mungkin cocok untuk pengguna. Nah, anime yang akan direkomendasikan tentulah anime yang belum pernah ditonton oleh pengguna. Oleh karena itu, kita perlu membuat variabel anime_not_visited sebagai daftar anime untuk direkomendasikan pada pengguna.
"""

data_anime = anime_new[:2000]
df = pd.read_csv('/content/drive/MyDrive/Kaggle/Dataset Anime/rating.csv')
df = df[:2000]

# Mengambil sample user
user_id = df.user_id.sample(1).iloc[0]
anime_visited_by_user = df[df.user_id == user_id]

anime_not_visited = data_anime[~data_anime['id'].isin(anime_visited_by_user.anime_id.values)]['id']
anime_not_visited = list(
    set(anime_not_visited)
    .intersection(set(anime_to_anime_encoded.keys()))
)

anime_not_visited = [[anime_to_anime_encoded.get(x)] for x in anime_not_visited]
user_encoder = user_to_user_encoded.get(user_id)
user_anime_array = np.hstack(
    ([[user_encoder]] * len(anime_not_visited), anime_not_visited)
)

ratings = model.predict(user_anime_array).flatten()

top_ratings_indices = ratings.argsort()[-10:][::-1]
recommended_anime_ids = [
    anime_encoded_to_anime.get(anime_not_visited[x][0]) for x in top_ratings_indices
]

print('Menampilkan rekomendasi anime dari user: {}'.format(user_id))
print('===' * 9)
print('Anime dengan Rating Tertinggi dari user')
print('----' * 8)

top_anime_user = (
    anime_visited_by_user.sort_values(
        by = 'rating',
        ascending=False
    )
    .head(5)
    .anime_id.values
)

data_anime_rows = data_anime[data_anime['id'].isin(top_anime_user)]
for row in data_anime_rows.itertuples():
    print(row.anime_name, ':', row.genre)

print('----' * 8)
print('Top 10 Rekomendasi Anime untuk User')
print('----' * 8)

recommended_anime = data_anime[data_anime['id'].isin(recommended_anime_ids)]
for row in recommended_anime.itertuples():
    print(row.anime_name, ':', row.genre)

"""Sebagai contoh, hasil di atas adalah rekomendasi untuk user dengan id 17. Dari output tersebut, kita dapat membandingkan antara anime dengan rating tertinggi dari user dan Top 10 anime recommendation untuk user.

Perhatikanlah, beberapa anime rekomendasi menyediakan genre yang sesuai dengan rating user. Rekomendasi yang paling banyak dihasilkan yaitu anime dengan genre Comedy, Action, dan Shounen
"""

